/*{{{+++++++++++++++++++++++ <Description> ++++++++++++++++++++++++++
 * John's friend Peter purchases a new high resolution monitor with 
 * dimension W * H where W is the number of pixels in each row (i.e. width) 
 * and H is the number of pixels in each column (i.e. height).
 * 
 * However, there are N dead pixels on the monitor. 
 * The i-th dead pixel is located at (x[i], y[i]). 
 * (0, 0) is the top-left pixel and (W - 1, H - 1) is the bottom-right pixel. 
 * The locations of the dead pixels could be generated by 6 given integers X, Y, a, b, c and d by the following rules. 
 * If 2 pixels are at the same location, they are considered the same. 
 * It is possible that there are less than N distinct dead pixels.
 * 
 * x[0] = X
 * y[0] = Y
 * x[i] = (x[i - 1] * a + y[i - 1] * b + 1) % W (for 0 < i < N)
 * y[i] = (x[i - 1] * c + y[i - 1] * d + 1) % H (for 0 < i < N)
 * Peter connects his monitor to his computer and opens an image with dimension P (width) * Q (height).
 * How many unique positions can the image be placed so that it can be displayed perfectly 
 * (i.e. all pixels of the picture are shown on the monitor)? The image cannot be rotated.
 * 
 * Input
 * The first line contains an integer T, which is the number of test cases. 
 * Then T test cases follow. Each test case contains 11 integers W, H, P, Q, N, X, Y, a, b, c, d.
 * 
 * Output
 * For each of the test cases numbered in order from 1 to T, 
 * output "Case #", followed by the case number (with 1 being the first test case), 
 * followed by ": ", followed by an integer which is the number of different possible positions for the poster.
 * 
 * Constraints
 * 1 ≤ T ≤ 20
 * 1 ≤ W, H ≤ 40 000 W*H<=1 600 000 000
 * 1 ≤ P ≤ W
 * 1 ≤ Q ≤ H
 * 1 ≤ N ≤ min(1 000 000, W * H)
 * 1 ≤ a, b, c, d ≤ 100
 * 0 ≤ X < W
 * 0 ≤ Y < H
 *  
 * 
 * Example input
 * 5
 * 4 4 2 2 1 0 2 1 2 3 4
 * 4 4 1 1 3 1 1 2 2 2 2
 * 6 10 3 2 2 0 0 5 4 3 2
 * 16 18 5 1 5 10 8 21 27 29 87
 * 14 15 12 4 4 3 5 84 74 53 68
 *
 * Example output
 * Case #1: 7
 * Case #2: 15
 * Case #3: 32
 * Case #4: 197
 * Case #5: 16
 * -------------------------------------------------------------}}}*/
#include <stdio.h>
#include <string.h>
#include <set>

class BitMap {
    public:
        explicit BitMap(size_t width, size_t height=1) : width_(width), map_(NULL) {
            size_t SZ = (width_*height)/8+((width_*height)%8?1:0);
            if (SZ) {
                map_ = new char[SZ];
                memset(map_, 0, SZ);
            }
        }
        void set(size_t w, size_t h=0) {
            int index = w+h*width_;
            map_[index/8] |= (1<<(index%8));
        }
        bool check(size_t w, size_t h=0) {
            int index = w+h*width_;
            return map_[index/8]&(1<<(index%8));
        }
        ~BitMap() {
            if (map_) 
                delete [] map_;
        }
    private:
        BitMap() {}
        BitMap operator=(const BitMap &) {}
    private:
        size_t width_;
        char * map_;
};

int solve(int W,int H,int P,int Q,int N,int X,int Y,int a,int b,int c,int d) {
    BitMap bad(W, H);
    for (int i=0,x=X,y=Y,t; i<N; ++i) {
        bad.set(x, y);;
        t = x;
        x = (x*a+y*b+1)%W;
        y = (t*c+y*d+1)%H;
    }

    int heights[W];
    memset(heights, 0, sizeof(heights));
    int num = 0;
    for (int h=0; h<H; ++h) {
        int p = 0;
        for (int i=0; i<W; ++i) {
            heights[i] = (bad.check(i, h) ? 0 : heights[i]+1);
            p = (heights[i]>=Q?p+1:0);
            if (p>=P) ++num;
        }
    }
    return num;
}

int main(int argc, char * argv[]) {
    int T;
    scanf("%d\n", &T);
    for (int i=1; i<=T; ++i) {
        int W, H, P, Q, N, X, Y, a, b, c, d;
        scanf("%d%d%d%d%d%d%d%d%d%d%d\n", &W,&H,&P,&Q,&N,&X,&Y,&a,&b,&c,&d);
        printf("Case #%d: %u\n", i, solve(W, H, P, Q, N, X, Y, a, b, c, d));
    }
    return 0;
}
